import scala.util.matching.Regex

sealed trait SetExpr {
  def evaluate(sets: Map[String, Set[Int]]): Set[Int]
}
case class SetVar(name: String) extends SetExpr {
  override def evaluate(sets: Map[String, Set[Int]]): Set[Int] = sets.getOrElse(name, Set.empty)
}
case class Union(left: SetExpr, right: SetExpr) extends SetExpr {
  override def evaluate(sets: Map[String, Set[Int]]): Set[Int] = left.evaluate(sets) | right.evaluate(sets)
}
case class Intersection(left: SetExpr, right: SetExpr) extends SetExpr {
  override def evaluate(sets: Map[String, Set[Int]]): Set[Int] = left.evaluate(sets) & right.evaluate(sets)
}

object SetParser {
    def variable(input: String): SetExpr = 
        """[A-Z]""".r.findFirstIn(input) match 
            case Some(value) => SetVar(value)
            case None => throw new IllegalArgumentException("Invalid Set")

    def parseExpression(input: String): SetExpr = {
        // Se houver parênteses, resolve o mais interno primeiro
        val parenthesized = """\(([^()]+)\)""".r
        parenthesized.findFirstMatchIn(input) match {
            case Some(m) => 
                // Resolve a subexpressão mais interna e substitui no input
                val innerExpr = parseExpression(m.group(1))
                val newInput = input.replace(m.group(0), s"_TEMP_${innerExpr}")
                parseExpression(newInput)
            case None => parseNonParenthesized(input)
        }
    }

    def parseNonParenthesized(input: String): SetExpr = {
        // Avalia a expressão da esquerda para a direita, priorizando apenas por ordem de aparição
        val tokenized = """([A-Z]+|\||&)""".r.findAllIn(input).toList
        parseTokens(tokenized)
    }

    def parseTokens(tokens: List[String]): SetExpr = {
        tokens match {
            case left :: "|" :: right :: rest =>
                Union(parseSingleToken(left), parseTokens(right :: rest))
            case left :: "&" :: right :: rest =>
                Intersection(parseSingleToken(left), parseTokens(right :: rest))
            case singleToken :: Nil => parseSingleToken(singleToken)
            case Nil => throw new IllegalArgumentException("Empty expression")
        }
    }

    def parseSingleToken(token: String): SetExpr = {
        token match {
            case name if name.matches("[A-Z]") => variable(name)
            case expr if expr.startsWith("_TEMP_") =>
                // Recupera a subexpressão temporária já resolvida
                val innerExpr = expr.stripPrefix("_TEMP_")
                variable(innerExpr)
            case _ => throw new IllegalArgumentException(s"Invalid token: $token")
        }
    }

    def parse(expression: String): SetExpr = parseExpression(expression)
}

@main
def run(): Unit = {
    val sets = Map("A" -> Set(1, 2), "B" -> Set(3, 4, 7), "C" -> Set(5, 6))
    val expr = "A | (B & C)"

    val result = SetParser.parse(expr).evaluate(sets)
    println(s"O resultado da expressao e: $result")
}


//================Codigo antigo
def union(input: String): SetExpr =
        val regex: Regex = """(.*)\s*\|\s*(.*)""".r;
        regex.findFirstMatchIn(input) match
            case Some(result) => 
                val left =  if result.group(1).length > 1 then term(result.group(1)) else result.group(1)
                val right = if result.group(2).length > 1 then term(result.group(2)) else result.group(2)
                Union(variable(left.toString), variable(right.toString))
            case _ => throw new IllegalArgumentException("Invalid Union")

    def intersection(input: String): SetExpr =
        val regex: Regex = """(.*)\s*\&\s*(.*)""".r;
        regex.findFirstMatchIn(input) match
            case Some(result) => 
                println(s"Resultado do INTERSECTION: $result")
                val left = result.group(1)
                val right = result.group(2)
                println(s"Resultado do INTERSECTION - LEFT: $left")
                println(s"Resultado do INTERSECTION - RIGHT: $right")
                Intersection(variable(left), variable(right))
            case _ => throw new IllegalArgumentException("Invalid Union")

    def term(input: String): SetExpr = 
        if (input.contains("|")) union(input)
        else if (input.contains("&")) intersection(input)
        else variable(input)